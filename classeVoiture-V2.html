<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classe VOITURE version 2</title>
</head>
<body>
    <h1>3.1 CLASSE MÉTIER ET APPLICATION DE TYPE CONSOLE</h1>
    <p>
        L'application minimale envisagée ici comprendra la définition de la classe ‘Métier' (Voiture) et un programme procédural de type console (parcAuto) utilisant cette classe. <br/>
        Comme on souhaite que la classe Métier reste indépendante de son usage par une application particulière, elle n'effectue aucun affichage direct ; les messages générés sont stockés dans un attribut accessible par le getter correspondant, et c'est bien le programme principal qui saura les récupérer et les restituer à l'utilisateur comme bon lui semble (ici, simples affichages séquentiels sur la console). En cas d'erreur importante, la classe Métier pourra aussi lever une Exception (gérée dans le programme principal).
    </p>

    <h1>3.2 LA CLASSE MÉTIER VOITURE</h1>
    <p>
        Il s'agit ici de développer une classe représentant (de manière simplifiée !) une voiture du parc automobile de l'entreprise cliente.
        Nom de la classe : Voiture
    </p>

    <h2>Attributs privés</h2>
    <p>
        Les différents attributs privés nécessaires pour représenter les données caractéristiques d'un véhicule se limitent pour l'instant à :
        <li>Immatriculation – string</li>
        <li>Couleur – string</li>
        <li>Poids – int</li>
        <li>Puissance – int</li>
        <li>Capacité du réservoir – float</li>
        <li>Niveau d'essence – float</li>
        <li>Nombre de place – int</li>
        <li>Assuré – bool</li>
        <li>Message au tableau de bord – string</li>
    </p>

    <h2>Constructeurs</h2>
    <p>
        Un constructeur par défaut n'a pas de sens dans cette application. <br/>
        On peut créer une voiture connaissant au moins les données qui ne pourront pas changer :
        <li>Immatriculation</li>
        <li>Couleur</li>
        <li>Poids</li>
        <li>Puissance</li>
        <li>Capacité du réservoir</li>
        <li>Nombre de place</li><br/>
        A la livraison, le réservoir du véhicule est fourni avec 5 litres de carburant, 
        et le véhicule n'est pas assuré (mais le tableau de bord peut déjà afficher un message d'accueil).
    </p>

    <h2>Propriétés (getters et setters)</h2>
    <p>
        La classe Voiture expose des accesseurs standards en lecture (sans contrôle) pour chacun des attributs privés.
        Pour ces véhicules, seul l'indicateur d'assurance peut être affecté directement de l'extérieur. L'accesseur en écriture correspondant effectuera donc :
        <li>Mise à jour de l'indicateur booléen d'assurance.</li>
        <li>Génération d'un message pour le tableau de bord.</li>
    </p>
        

    <h2>Méthode exposée : Repeindre la voiture</h2>
    <p>
        La classe Voiture expose la méthode repeindre() qui admet en paramètre le libellé de la nouvelle couleur.<br/>
        Si cette nouvelle couleur est identique à la couleur courante, la méthode génère simplement un message remerciant pour ce rafraîchissement ;<br>
        s'il s'agit d'une couleur différente, il la mémorise dans l'attribut correspondant et génère un autre message de remerciement.<br>
        Cette méthode pourrait aussi bien retourner un code d'erreur, par exemple un booléen true si tout va bien ou false sinon.
    </p>

    <h2>Méthode exposée : Faire l'appoint d'essence</h2>
    <p>
        La classe Voiture expose la méthode mettreEssence() 
        qui admet en paramètre une quantité de carburant à ajouter au réservoir. <br/>
        Cette méthode effectue tout d'abord un test 
        pour savoir si cette quantité est compatible avec le niveau d'essence courant du véhicule ; <br/>
        si tout va bien, elle ajoute le carburant et génère un message de feed-back, <br/>
        sinon, elle refuse cet appoint de carburant et génère un message d'erreur.<br/>
        Cette méthode doit retourner au programme appelant le nouveau niveau de carburant.
    </p>

    <h2>Méthode exposée : Se déplacer</h2>
    <p>
        C'est bien le but d'un véhicule ! <br/>

        La classe Voiture expose la méthode seDeplacer() qui admet en paramètres la distance parcourue en km 
        et la vitesse moyenne du déplacement. <br/>

        En fonction de ces deux paramètres, la méthode calcule tout d'abord la consommation de carburant 
        selon la règle de gestion (très simplifiée) : <br/>
        <li>Consommation de 10 l aux 100 km en ville, soit à une vitesse moyenne inférieure à 50 km/h ;</li>
        <li>Consommation de 5 l aux 100 km en sur route, soit à une vitesse moyenne comprise entre 50 et 90 km/h ;</li>
        <li>Consommation de 8 l aux 100 km en sur autoroute, soit à une vitesse moyenne comprise entre 90 et 130 km/h ;</li>
        <li>Consommation de 12 l aux 100 km pour une vitesse moyenne supérieure à 130 km/h 
            (et on ne parle pas des retraits de points de permis...) ;</li>
       
        Conseil <br/>
        Ce calcul élémentaire de consommation pourrait bien faire l'objet d'une nouvelle méthode privée 
        qui serait alors réutilisable par la classe elle-même... <br/>

        D'après cette consommation nécessaire de carburant, la méthode détermine 
        si ce trajet est possible en fonction du niveau d'essence courant. 
        Si ce n'est pas le cas, elle génère un message d'erreur. 
        Et si tout va bien, elle déduit la consommation calculée et génère un message indiquant cette consommation.
    </p>

    <h2>Méthode exposée redéfinie toString()</h2>
    <p>
        Il est de bonne pratique de redéfinir dans chaque classe la méthode toString() héritée de la classe Object.
        Dans notre classe Voiture, cette méthode toString() doit retourner un libellé rappelant simplement l'immatriculation, la puissance et la couleur du véhicule.
    </p>


    <script src="classeVoiture-V2.js"></script>
</body>
</html>